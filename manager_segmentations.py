"""
Manager for segmentations, whether expert generated or Total Segmentator generated.
Expert generated segmentations are generated by convert_to_hdf_cropped.py.
Total Segmentator generated segmentations are generated by convert_total_segmentator_to_cropped_hdf.py.
"""

import pandas as pd
import os
import numpy as np
import h5py
import torch
import tqdm

shape_info = pd.read_csv("data_hdf5_cropped/shape_info.csv", index_col=1)
series_meta = pd.read_csv("data/train_series_meta.csv", index_col=1)

EXPERT_SEGMENTATION_FOLDER = "data_segmentation_hdf_cropped"
TSM_SEGMENTATION_FOLDER = "total_segmentator_hdf_cropped"
SEGMENTATION_LABELS_FOLDER = "segmentation_injury_labels" # localized injury labels generated by segmentations

def get_mean_slope(series_id):
    return shape_info.loc[int(series_id), "mean_slope"]

def patient_has_expert_segmentations(patient_id):
    relevant_segmentations = list(series_meta.loc[series_meta["patient_id"] == int(patient_id)].index)
    for series_id in relevant_segmentations:
        if os.path.isfile(os.path.join(EXPERT_SEGMENTATION_FOLDER, str(series_id) + ".hdf5")):
            return True
    return False

def patient_has_TSM_segmentations(patient_id):
    relevant_segmentations = list(series_meta.loc[series_meta["patient_id"] == int(patient_id)].index)
    for series_id in relevant_segmentations:
        if os.path.isfile(os.path.join(TSM_SEGMENTATION_FOLDER, str(series_id) + ".hdf5")):
            return True
    return False

def randomly_pick_expert_segmentation(patient_id):
    all_segmentations = list(series_meta.loc[series_meta["patient_id"] == int(patient_id)].index)
    relevant_segmentations = []
    for series_id in all_segmentations:
        if os.path.isfile(os.path.join(EXPERT_SEGMENTATION_FOLDER, str(series_id) + ".hdf5")):
            relevant_segmentations.append(series_id)
    assert len(relevant_segmentations) > 0, "No expert segmentations found for patient " + str(patient_id)
    return relevant_segmentations[np.random.randint(len(relevant_segmentations))]

def randomly_pick_TSM_segmentation(patient_id):
    all_segmentations = list(series_meta.loc[series_meta["patient_id"] == int(patient_id)].index)
    relevant_segmentations = []
    for series_id in all_segmentations:
        if os.path.isfile(os.path.join(TSM_SEGMENTATION_FOLDER, str(series_id) + ".hdf5")):
            relevant_segmentations.append(series_id)
    assert len(relevant_segmentations) > 0, "No TSM segmentations found for patient " + str(patient_id)
    return relevant_segmentations[np.random.randint(len(relevant_segmentations))]

def get_patients_with_expert_segmentation() -> list[str]:
    expert_segmentation_series_id = [int(x[:-5]) for x in os.listdir(EXPERT_SEGMENTATION_FOLDER)]
    patient_ids = list(series_meta.loc[expert_segmentation_series_id, "patient_id"].unique())
    return [str(x) for x in patient_ids]

def get_patients_with_TSM_segmentation(only_negative_slope=False) -> list[str]:
    TSM_segmentation_series_id = [int(x[:-5]) for x in os.listdir(TSM_SEGMENTATION_FOLDER)]
    if only_negative_slope:
        TSM_segmentation_series_id = [x for x in TSM_segmentation_series_id if get_mean_slope(x) < 0]
    patient_ids = list(series_meta.loc[TSM_segmentation_series_id, "patient_id"].unique())
    return [str(x) for x in patient_ids]

def restrict_patients_to_expert_segmentation(patients: list[str]) -> list[str]:
    patients_with_segmentations = get_patients_with_expert_segmentation()
    return [x for x in patients if str(x) in patients_with_segmentations]

def restrict_patients_to_TSM_segmentation(patients: list[str]) -> list[str]:
    patients_with_segmentations = get_patients_with_TSM_segmentation()
    return [x for x in patients if str(x) in patients_with_segmentations]

def restrict_patients_to_TSM_but_no_expert_segmentation(patients: list[str]) -> list[str]:
    patients_with_TSM_segmentations = get_patients_with_TSM_segmentation()
    patients_with_expert_segmentations = get_patients_with_expert_segmentation()
    return [x for x in patients if str(x) in patients_with_TSM_segmentations and str(x) not in patients_with_expert_segmentations]

patient_injuries: pd.DataFrame=None
slice_level_injuries: pd.DataFrame=None
def get_segmentation_injury_labels(patient_id: str, series_id: str, expert_segmentation: bool) -> np.ndarray:
    """
    Returns a (depth, 5) array of injury labels for each slice in the series. The classes are ordered as follows:
    0 - liver
    1 - spleen
    2 - kidney
    3 - bowel
    4 - extravasation
    """

    # load injuries
    global patient_injuries, slice_level_injuries
    if patient_injuries is None:
        patient_injuries = pd.read_csv("data/train.csv", index_col=0)
    if slice_level_injuries is None:
        slice_level_injuries = pd.read_csv("data/image_level_labels.csv")
    injury_summary = patient_injuries.loc[int(patient_id)]
    slice_level_injury_summary = slice_level_injuries.loc[(slice_level_injuries["patient_id"] == int(patient_id))
                                                          & (slice_level_injuries["series_id"] == int(series_id))]

    # load segmentations
    if expert_segmentation:
        folder = EXPERT_SEGMENTATION_FOLDER
    else:
        folder = TSM_SEGMENTATION_FOLDER
    segmentation_file = os.path.join(folder, "{}.hdf5".format(series_id))
    with h5py.File(segmentation_file, "r") as f:
        segmentations = f["segmentation_arr"][()]

    # create slice level labels
    series_folder = os.path.join("data", "train_images", patient_id, series_id)
    series_slices = [int(x[:-4]) for x in os.listdir(series_folder)]
    length = max(series_slices) + 1 - min(series_slices)
    assert length == segmentations.shape[0], "Depth mismatch between segmentations and slices"

    segmentations = torch.tensor(segmentations, dtype=torch.float32, device="cuda")
    injury_labels = np.zeros(shape=(length, 5), dtype=np.uint8) # 5 classes
    if injury_summary["liver_low"] == 1:
        injury_labels[:, 0] = torch.any((segmentations[..., 0] > 0)\
                                        .view(length, -1), dim=1).cpu().numpy().astype(dtype=np.uint8)
    elif injury_summary["liver_high"] == 1:
        injury_labels[:, 0] = 2 * torch.any((segmentations[..., 0] > 0) \
                                        .view(length, -1), dim=1).cpu().numpy().astype(dtype=np.uint8)
    if injury_summary["spleen_low"] == 1:
        injury_labels[:, 1] = torch.any((segmentations[..., 1] > 0) \
                                            .view(length, -1), dim=1).cpu().numpy().astype(dtype=np.uint8)
    elif injury_summary["spleen_high"] == 1:
        injury_labels[:, 1] = 2 * torch.any((segmentations[..., 1] > 0) \
                                        .view(length, -1), dim=1).cpu().numpy().astype(dtype=np.uint8)
    if injury_summary["kidney_low"] == 1: # in segmentation file, left and right kidney is saved as 2, 3. Combine them.
        injury_labels[:, 2] = torch.any(torch.logical_or((segmentations[..., 2] > 0), (segmentations[..., 3] > 0)) \
                                        .view(length, -1), dim=1).cpu().numpy().astype(dtype=np.uint8)
    elif injury_summary["kidney_high"] == 1: # in segmentation file, left and right kidney is saved as 2, 3. Combine them.
        injury_labels[:, 2] = 2 * torch.any(torch.logical_or((segmentations[..., 2] > 0), (segmentations[..., 3] > 0)) \
                                        .view(length, -1), dim=1).cpu().numpy().astype(dtype=np.uint8)

    for k in range(len(slice_level_injury_summary)):
        slice = slice_level_injury_summary.iloc[k]
        index = int(slice["instance_number"]) - min(series_slices)
        if slice["injury_name"] == "Active_Extravasation":
            injury_labels[index, 4] = 1
        elif slice["injury_name"] == "Bowel":
            injury_labels[index, 3] = 1
        else:
            raise ValueError("Unknown injury name: " + slice["injury_name"])

    return injury_labels

if __name__ == "__main__":
    if not os.path.isdir(SEGMENTATION_LABELS_FOLDER):
        os.mkdir(SEGMENTATION_LABELS_FOLDER)

    expert_segmentations = [int(x[:-5]) for x in os.listdir(EXPERT_SEGMENTATION_FOLDER)]
    TSM_segmentations = [int(x[:-5]) for x in os.listdir(TSM_SEGMENTATION_FOLDER)]
    TSM_segmentations = [x for x in TSM_segmentations if x not in expert_segmentations]
    for series_id in tqdm.tqdm(expert_segmentations):
        file = os.path.join(SEGMENTATION_LABELS_FOLDER, "{}.npy".format(series_id))
        if not os.path.exists(file): # if already generated, skip
            patient_id = series_meta.loc[series_id, "patient_id"]
            injury_labels = get_segmentation_injury_labels(str(patient_id), str(series_id), True)
            np.save(file, injury_labels)

    for series_id in tqdm.tqdm(TSM_segmentations):
        file = os.path.join(SEGMENTATION_LABELS_FOLDER, "{}.npy".format(series_id))
        if not os.path.exists(file): # if already generated, skip
            patient_id = series_meta.loc[series_id, "patient_id"]
            injury_labels = get_segmentation_injury_labels(str(patient_id), str(series_id), False)
            np.save(file, injury_labels)
